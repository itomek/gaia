# Copyright(C) 2025-2026 Advanced Micro Devices, Inc. All rights reserved.
# SPDX-License-Identifier: MIT
#
# Fork PR Support:
# - pr-review (pull_request_target): ‚úÖ Works on fork PRs - auto-reviews when PR opened (gracefully handles permission warnings)
# - issue-handler (issue_comment): ‚úÖ Works on fork PRs - responds to @claude in PR conversations
# - pr-comment (pull_request_review_comment): ‚ùå Only non-fork PRs - GitHub doesn't expose secrets to this event on forks
#
# SECURITY: pull_request_target runs with base repo permissions (access to secrets) even on fork PRs.
# This is SAFE here because:
# 1. We checkout the PR code for analysis but don't execute it
# 2. Claude only reads code and posts comments (no code execution)
# 3. All actions are review/comment operations, not builds or tests
#
# IMPORTANT: Never add steps that execute code from the PR (npm install, pip install, make, etc.)
#
# COST: Fork PRs will consume your Anthropic API quota.

name: Claude AI Assistant

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created, edited]
  pull_request_target:
    types: [opened, ready_for_review]
  pull_request_review_comment:
    types: [created, edited]
  workflow_run:
    workflows: ["PyPi"]
    types: [completed]

permissions:
  contents: write  # Allows Claude to post suggested changes (requires write for GitHub API)
  issues: write
  pull-requests: write

jobs:
  # Auto-review new PRs (including forks)
  pr-review:
    if: |
      github.event_name == 'pull_request_target' &&
      (github.event.pull_request.draft == false ||
       contains(github.event.pull_request.labels.*.name, 'ready_for_ci'))
    runs-on: ubuntu-latest
    concurrency:
      group: claude-pr-review-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Generate PR diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
        run: |
          echo "Generating diff from $BASE_BRANCH to PR head"

          # Fetch base branch
          git fetch origin "$BASE_BRANCH"

          # Generate diff in repo root (where Claude has access)
          git diff "origin/$BASE_BRANCH...HEAD" > pr-diff.txt
          git diff --name-status "origin/$BASE_BRANCH...HEAD" > pr-files.txt

          echo "Diff generated: $(wc -l < pr-diff.txt) lines"
          echo "Files changed: $(wc -l < pr-files.txt) files"

      - name: Run Claude Code Review
        uses: anthropics/claude-code-action@beta
        continue-on-error: true  # Gracefully handle permission errors for fork PRs
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          max_turns: 20
          model: claude-opus-4-5-20251101
          custom_instructions: |
            You are reviewing a GAIA pull request. Provide a thorough, professional code review following GAIA standards.

            ## FIRST ACTIONS (Do these immediately)
            1. Read pr-diff.txt - This shows ALL changes in the PR
            2. Read pr-files.txt - This lists changed files
            3. Then selectively read files based on what changed

            **Context Available:**
            - Repository is checked out at the PR head
            - Focus your review on the changed files and their impact

            **CRITICAL: File Reading Strategy**
            - **DO NOT** read entire large files (>1000 lines) - you'll hit token limits
            - For large files like cli.py:
              1. Use pr-diff.txt to see the changed sections
              2. Use Grep with context: `grep -C 10 "pattern"`
              3. Use Read with offset/limit for specific line ranges
            - Focus on reviewing CHANGED code, not reading entire files
            - **Complete your review even if you can't read every file** - partial review is better than none

            ## Suggested Changes Policy

            **IMPORTANT: Maximize use of actionable ```suggestion blocks** - These provide immediate value to contributors.

            **DO NOT review or flag:**
            - ‚ùå Copyright headers (presence, absence, or year inconsistencies)
            - ‚ùå SPDX license identifiers
            - ‚ùå License-related boilerplate
            This is an open-source project - contributors retain their own copyright.

            **Always provide suggestions for:**
            - ‚úÖ Import sorting issues (isort violations)
            - ‚úÖ Code formatting issues (black violations)
            - ‚úÖ Trailing whitespace, missing newlines at EOF
            - ‚úÖ Simple typos in comments or docstrings
            - ‚úÖ Exception handling patterns (show correct pattern from existing agents)
            - ‚úÖ Missing type hints
            - ‚úÖ Hardcoded values that should use constants
            - ‚úÖ Logging improvements (e.g., truncating verbose output)
            - ‚úÖ Simple bug fixes with clear solutions

            **When suggesting patterns from existing code:**
            - Reference similar code in `src/gaia/agents/` or `src/gaia/`
            - Show the correct pattern as a concrete ```suggestion block
            - Example: "Other agents handle this using [pattern from file.py:123]"

            **Format suggestions using GitHub's syntax:**
            ```suggestion
            corrected code here
            ```

            **Comment only (no suggestion):**
            - üîí **Security vulnerabilities** - Tag @kovtcharov-amd immediately
            - Complex architectural decisions requiring discussion
            - Changes with multiple valid approaches
            - Breaking changes requiring maintainer decision

            **For repeated issues (e.g., same problem in 5 locations):**
            - Provide ONE example ```suggestion showing the correct pattern
            - List all affected locations
            - Let the author apply the pattern consistently

            ## Review Checklist

            ### 1. Code Quality & Patterns
            - **Architecture Consistency:** For new agents, compare with existing agents in `src/gaia/agents/`
              - Does it follow the same base class patterns?
              - Does error handling match other agents?
              - Are logging patterns consistent?
            - **Pattern Reuse:** Check if similar functionality exists elsewhere
              - Look for code duplication that should be refactored
              - Reference existing implementations when suggesting improvements
            - **Error Handling:** Review exception handling patterns
              - Avoid bare `except:` or silent `except Exception: pass`
              - Show correct pattern from existing agents
            - **Code Style:** Check readability and maintainability
            - **Standards Compliance:** Reference CLAUDE.md and docs/reference/dev.md

            ### 2. Security Review (CRITICAL)
            Review for these vulnerabilities:
            - üîí SQL injection vulnerabilities
            - üîí Command injection (especially in shell tools, Bash usage)
            - üîí XSS vulnerabilities (web UIs, HTML generation)
            - üîí Secrets exposure (API keys, tokens in code/logs)
            - üîí Path traversal vulnerabilities
            - üîí Unsafe deserialization
            - üîí Resource cleanup issues (temp files, file handles, connections)

            **MANDATORY: If ANY security issues found:**
            1. Comment with "üîí SECURITY CONCERN: [brief description]"
            2. Tag @kovtcharov-amd in the same comment
            3. Mark as üî¥ Critical severity
            4. Do NOT provide detailed exploit information publicly

            ### 3. Testing
            - Check if tests exist in `tests/` for new functionality
            - Review test quality (not just coverage):
              - Do tests cover edge cases?
              - Are tests readable and maintainable?
              - Do they test the right things?
            - Verify existing tests still pass (check CI status)

            ### 4. Documentation
            - **New Features:** Check if documentation exists in `docs/`
              - New agents should have guide in `docs/guides/`
              - New CLI commands should update `docs/reference/cli.md`
              - New SDK features should update relevant files in `docs/sdk/`
            - **API Changes:** Verify docs/ updates match code changes
            - **Code Comments:** Validate comments for complex logic
            - **Quality Checks (for major features or doc updates):**
              - **Accuracy**: Technical content is correct and up-to-date
              - **Completeness**: All necessary information is included
              - **Clarity**: Content is clear and well-organized
              - **Links**: Internal/external links are valid
              - **Code Examples**: Code snippets are correct and runnable
              - **Consistency**: Follows documentation style guide

            ### 5. Breaking Changes & Compatibility
            - Identify any breaking changes to public APIs
            - Check backward compatibility considerations
            - Review migration impact for existing users

            ### 6. Performance & Architecture
            - Flag potential performance issues (N+1 queries, inefficient algorithms)
            - Review architectural decisions
            - Check for unnecessary new dependencies

            ### 7. Commit Quality
            - Review commit messages for clarity
            - Check if commits are logically organized

            ## Output Format

            **Structure your review as follows:**

            1. **Summary** (2-3 sentences)
               - Overall code quality assessment
               - Main strengths and concerns

            2. **Issues Found** (if any)
               Use consistent severity emojis:
               - üî¥ **Critical** - Security issues, breaking changes, data loss risks
               - üü° **Important** - Bugs, architectural concerns, missing tests
               - üü¢ **Minor** - Style issues, optimizations, suggestions

               Format: `[Emoji] Issue title (file.py:123)`
               - Describe the problem briefly
               - Provide ```suggestion block OR explain why discussion needed

            3. **Strengths** (always include, even for PRs with issues)
               - What's implemented well
               - Good patterns followed
               - Do NOT mention copyright headers as a strength

            4. **Verdict**
               - **Approve** - No blocking issues, ready to merge
               - **Approve with suggestions** - Minor issues, can merge after applying suggestions
               - **Request changes** - Blocking issues that must be addressed

            **For clean PRs with no issues:**
            Still provide Summary, Strengths, and "Approve" verdict. Acknowledge the good work.

            **Writing Style:**
            - Be professional, constructive, and specific
            - Assume the author is skilled but may not know GAIA conventions
            - Prioritize ```suggestion blocks over descriptions
            - Make it easy for maintainers to accept suggestions with one click

  # Respond to @claude in PR review comments (non-fork PRs only - secrets unavailable on forks)
  pr-comment:
    if: |
      github.event_name == 'pull_request_review_comment' &&
      contains(github.event.comment.body, '@claude') &&
      github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    concurrency:
      group: claude-pr-comment-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Generate PR diff
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BASE_BRANCH: ${{ github.event.pull_request.base.ref }}
        run: |
          echo "Generating diff from $BASE_BRANCH to current PR head"

          # Fetch base branch
          git fetch origin "$BASE_BRANCH"

          # Generate diff in repo root (where Claude has access)
          git diff "origin/$BASE_BRANCH...HEAD" > pr-diff.txt
          git diff --name-status "origin/$BASE_BRANCH...HEAD" > pr-files.txt

          echo "Diff generated: $(wc -l < pr-diff.txt) lines"
          echo "Files changed: $(wc -l < pr-files.txt) files"

      - name: Respond to PR comment
        uses: anthropics/claude-code-action@beta
        continue-on-error: true  # Gracefully handle permission errors
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          max_turns: 20
          model: claude-opus-4-5-20251101
          custom_instructions: |
            You are GAIA's AI assistant helping with pull request discussions.

            ## FIRST ACTIONS
            1. Read pr-diff.txt to see what changed
            2. Read pr-files.txt to see which files changed
            3. Understand the context of the user's question/request

            **File Reading Strategy:**
            - Use Grep for searching large files (>1000 lines)
            - Use Read with offset/limit for specific sections
            - Focus on changed code, not entire files

            ## When NOT to Respond
            - If @claude is mentioned but clearly addressing someone else
            - If the comment is just "thanks" or acknowledgment (no action needed)
            - If asking to merge/approve (you cannot do this - suggest asking a maintainer)

            ## Response Types

            **Provide ```suggestion blocks for:**
            - User explicitly asks to fix something ("@claude fix the formatting")
            - Simple, clear fixes (formatting, import sorting, typos)
            - Bug fixes with obvious solutions

            **Comment only (no suggestion) for:**
            - Answering questions or providing guidance
            - Discussing architectural approaches
            - üîí Security concerns - tag @kovtcharov-amd immediately
            - Changes with multiple valid approaches

            ## Response Format
            - **Be concise** - 1-3 paragraphs for simple questions
            - **Reference files** - Use `file.py:123` format
            - **Use severity emojis** when flagging issues: üî¥ Critical, üü° Important, üü¢ Minor
            - **End with next steps** if action is needed

            ## Limitations
            - You cannot merge PRs, approve reviews, or assign reviewers
            - You cannot run tests or CI pipelines
            - For these requests, suggest the user ask a maintainer

            Maintain a helpful, professional tone.

  # Respond to new issues or @claude mentions in PR conversations (including forks)
  issue-handler:
    if: |
      github.event_name == 'issues' ||
      (github.event_name == 'issue_comment' &&
       contains(github.event.comment.body, '@claude'))
    runs-on: ubuntu-latest
    concurrency:
      group: claude-issue-${{ github.event.issue.number }}
      cancel-in-progress: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      # If this is a PR comment, fetch and checkout the PR head
      - name: Checkout PR head and generate diff if commenting on PR
        if: github.event.issue.pull_request != null
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number }}
          REPO_OWNER: ${{ github.repository_owner }}
        run: |
          # PR_NUMBER comes from env to avoid shell injection

          # Get PR details including fork info
          PR_DATA=$(gh pr view $PR_NUMBER --json headRefOid,baseRefName,headRefName,headRepository,headRepositoryOwner)
          PR_HEAD_SHA=$(echo "$PR_DATA" | jq -r '.headRefOid')
          BASE_BRANCH=$(echo "$PR_DATA" | jq -r '.baseRefName')
          HEAD_REPO_OWNER=$(echo "$PR_DATA" | jq -r '.headRepositoryOwner.login')
          HEAD_REPO_NAME=$(echo "$PR_DATA" | jq -r '.headRepository.name')

          echo "PR #$PR_NUMBER: $BASE_BRANCH...$PR_HEAD_SHA"
          echo "Head repo: $HEAD_REPO_OWNER/$HEAD_REPO_NAME"

          # Fetch base branch from origin BEFORE any URL changes
          git fetch origin $BASE_BRANCH

          # Extract branch name first
          HEAD_REF=$(echo "$PR_DATA" | jq -r '.headRefName')

          # For fork PRs, temporarily redirect origin to the fork
          if [ "$HEAD_REPO_OWNER" != "$REPO_OWNER" ]; then
            echo "Fork PR detected: $HEAD_REPO_OWNER/$HEAD_REPO_NAME"

            # Temporarily point origin to the fork so the action's prepare.ts can fetch from it
            echo "Temporarily redirecting 'origin' remote to fork"
            git remote set-url origin https://github.com/$HEAD_REPO_OWNER/$HEAD_REPO_NAME.git

            # Fetch and checkout branch from origin (now pointing to fork)
            git fetch origin $HEAD_REF || {
              echo "Failed to fetch branch from fork. Fork may be private or deleted."
              exit 1
            }

            git checkout -b $HEAD_REF origin/$HEAD_REF

            echo "Successfully checked out $HEAD_REF (origin now points to fork)"
          else
            echo "Non-fork PR, fetching from origin"
            git fetch origin $PR_HEAD_SHA
            git checkout $PR_HEAD_SHA
            git checkout -b "$HEAD_REF" $PR_HEAD_SHA 2>/dev/null || git checkout "$HEAD_REF"
          fi

          # Generate diff in repo root (where Claude has access)
          echo "Generating diff between $BASE_BRANCH and PR head..."
          git diff origin/$BASE_BRANCH...$PR_HEAD_SHA > pr-diff.txt

          # Also get list of changed files
          git diff --name-status origin/$BASE_BRANCH...$PR_HEAD_SHA > pr-files.txt

          echo "Diff generated: $(wc -l < pr-diff.txt) lines"
          echo "Files changed: $(wc -l < pr-files.txt) files"

      - name: Respond to issue or PR comment
        uses: anthropics/claude-code-action@beta
        continue-on-error: true  # Gracefully handle permission errors
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          max_turns: 30
          model: claude-opus-4-5-20251101
          custom_instructions: |
            You are GAIA's helpful AI assistant responding to issues and PR conversations.

            ## Context Detection
            This handler responds to:
            - **New issues** - Follow the Issue Response Protocol
            - **PR conversation comments** - Focus on PR content (pr-diff.txt available)
            - **Issue comments with @claude** - Answer questions about the issue

            ## When NOT to Respond
            - Spam, promotional content, or off-topic issues
            - Comments that are just "thanks" or acknowledgments
            - @claude mentioned but clearly addressing someone else
            - Requests to merge/close (suggest asking a maintainer instead)

            ## FIRST ACTIONS
            **For PR conversations:**
            1. Read pr-diff.txt to see what changed
            2. Read pr-files.txt for changed file list
            3. Use Grep for large files (>1000 lines), Read with offset for sections

            **For issues:**
            1. Check for duplicate issues first
            2. Search docs/ for relevant documentation
            3. Search src/gaia/ for related code

            ## Issue Response Protocol

            ### For Questions
            Check docs/ folder:
            - **Setup:** docs/setup.md, docs/quickstart.md
            - **Guides:** docs/guides/chat.md, docs/guides/talk.md, docs/guides/code.md
            - **CLI:** docs/reference/cli.md, docs/reference/features.md
            - **SDK:** docs/sdk/core/agent-system.md, docs/sdk/sdks/
            - **FAQ:** docs/reference/faq.md

            ### For Bugs
            - Search src/gaia/ for related code
            - Check tests/ for related test cases
            - Ask for reproduction steps if not provided
            - üîí **Security bugs:** Tag @kovtcharov-amd, suggest private security advisory

            ### For Feature Requests
            - Check if similar exists in src/gaia/agents/ or src/gaia/apps/
            - Suggest approaches following existing patterns
            - Consider AMD hardware optimization opportunities

            ## Response Format
            - **Be concise:** 1-3 paragraphs for simple questions
            - **Reference files:** Use `src/gaia/file.py:123` format
            - **Link to docs:** Include relevant documentation links
            - **Use severity emojis:** üî¥ Critical, üü° Important, üü¢ Minor
            - **End with next steps:** Clear action items

            ## Escalation (tag @kovtcharov-amd)
            - üîí Security issues
            - Architecture decisions
            - Issues you cannot resolve
            - Roadmap/timeline questions

            ## Limitations
            - You cannot close issues, merge PRs, or assign labels
            - You cannot run tests or access external systems
            - For these requests, suggest asking a maintainer

            ## Tone
            - Friendly and professional
            - Assume good intent
            - Welcome contributors

  # Generate release notes when PyPi workflow completes successfully on a tag
  release-notes:
    if: |
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'success' &&
      startsWith(github.event.workflow_run.head_branch, 'v')
    runs-on: ubuntu-latest
    permissions:
      contents: write  # For committing release notes
      issues: write    # For creating failure notification issue
    concurrency:
      group: claude-release-notes-${{ github.event.workflow_run.head_branch }}
      cancel-in-progress: false
    steps:
      - name: Extract and validate tag name
        id: tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_BRANCH: ${{ github.event.workflow_run.head_branch }}
        run: |
          TAG_NAME="$HEAD_BRANCH"
          echo "Candidate tag: $TAG_NAME"

          # Validate semantic version format (vX.Y.Z)
          if [[ ! "$TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå '$TAG_NAME' is not a valid semantic version tag (expected vX.Y.Z)"
            echo "SKIP=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Verify the GitHub release exists
          if ! gh release view "$TAG_NAME" --repo "$GITHUB_REPOSITORY" > /dev/null 2>&1; then
            echo "‚ùå GitHub release for '$TAG_NAME' does not exist yet"
            echo "SKIP=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "‚úÖ Valid tag and release exists: $TAG_NAME"
          echo "TAG_NAME=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "SKIP=false" >> $GITHUB_OUTPUT

      - name: Checkout repository
        if: steps.tag.outputs.SKIP != 'true'
        uses: actions/checkout@v6
        with:
          ref: main       # Checkout main branch (not tag) so we can commit
          fetch-depth: 0  # Full history for tag comparison
          token: ${{ secrets.RELEASE_PAT }}  # PAT needed to push past branch protection

      - name: Fetch all tags
        if: steps.tag.outputs.SKIP != 'true'
        run: |
          git fetch --tags --force
          echo "Tags available:"
          git tag -l | tail -10

      - name: Generate release context
        if: steps.tag.outputs.SKIP != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CURRENT_TAG: ${{ steps.tag.outputs.TAG_NAME }}
        run: |
          echo "Generating release context for $CURRENT_TAG"

          # Ensure docs/releases directory exists
          mkdir -p docs/releases

          # Find previous tag using git describe (more reliable)
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 "$CURRENT_TAG^" 2>/dev/null || echo "")
          if [ -z "$PREVIOUS_TAG" ]; then
            # No previous tag found, use first commit
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
            echo "No previous tag found, using initial commit: $PREVIOUS_TAG"
          else
            echo "Previous tag: $PREVIOUS_TAG"
          fi
          echo "PREVIOUS_TAG=$PREVIOUS_TAG" >> $GITHUB_ENV

          # Generate diff statistics
          echo "## Release: $CURRENT_TAG" > release-context.txt
          echo "## Previous: $PREVIOUS_TAG" >> release-context.txt
          echo "" >> release-context.txt

          # Get commit count and contributor count
          COMMIT_COUNT=$(git rev-list --count $PREVIOUS_TAG..$CURRENT_TAG)
          CONTRIBUTOR_COUNT=$(git log $PREVIOUS_TAG..$CURRENT_TAG --format='%aN' | sort -u | wc -l)
          echo "**$COMMIT_COUNT commits** from **$CONTRIBUTOR_COUNT contributors**" >> release-context.txt
          echo "" >> release-context.txt

          # Get contributors
          echo "## Contributors" >> release-context.txt
          git log $PREVIOUS_TAG..$CURRENT_TAG --format='%aN' | sort -u >> release-context.txt
          echo "" >> release-context.txt

          # Get commit log with PR references (limit to 100 for large releases)
          echo "## Commit Log" >> release-context.txt
          git log $PREVIOUS_TAG..$CURRENT_TAG --oneline --no-merges | head -100 >> release-context.txt
          TOTAL_COMMITS=$(git log $PREVIOUS_TAG..$CURRENT_TAG --oneline --no-merges | wc -l)
          if [ "$TOTAL_COMMITS" -gt 100 ]; then
            echo "... and $((TOTAL_COMMITS - 100)) more commits" >> release-context.txt
          fi
          echo "" >> release-context.txt

          # Get merged PRs using GitHub's compare API (more accurate)
          echo "## Merged Pull Requests" >> release-context.txt
          gh api "repos/$GITHUB_REPOSITORY/compare/$PREVIOUS_TAG...$CURRENT_TAG" \
            --jq '.commits[].commit.message' 2>/dev/null | \
            grep -oE '#[0-9]+' | sort -u | while read pr; do
              pr_num="${pr#\#}"
              pr_info=$(gh pr view "$pr_num" --json title,author --jq '"\(.title) (@\(.author.login))"' 2>/dev/null || echo "")
              if [ -n "$pr_info" ]; then
                echo "#$pr_num - $pr_info" >> release-context.txt
              fi
            done
          echo "" >> release-context.txt

          # Get file change summary (not full diff - too large)
          echo "## Files Changed Summary" >> release-context.txt
          git diff --stat $PREVIOUS_TAG..$CURRENT_TAG | tail -20 >> release-context.txt
          echo "" >> release-context.txt

          # Get changed directories for context
          echo "## Changed Directories" >> release-context.txt
          git diff --name-only $PREVIOUS_TAG..$CURRENT_TAG | xargs -I {} dirname {} | sort -u | head -30 >> release-context.txt
          echo "" >> release-context.txt

          # Split diff into component-based files for iterative processing
          mkdir -p release-diffs

          # Create diffs by top-level directory for manageable chunks
          for dir in src tests docs .github installer examples; do
            if git diff --name-only $PREVIOUS_TAG..$CURRENT_TAG | grep -q "^$dir/"; then
              git diff $PREVIOUS_TAG..$CURRENT_TAG -- "$dir/" > "release-diffs/$dir.diff"
              LINES=$(wc -l < "release-diffs/$dir.diff")
              echo "  - release-diffs/$dir.diff: $LINES lines" >> release-context.txt
            fi
          done

          # Capture any remaining changes not in known directories
          git diff $PREVIOUS_TAG..$CURRENT_TAG -- ':!src/' ':!tests/' ':!docs/' ':!.github/' ':!installer/' ':!examples/' > release-diffs/other.diff 2>/dev/null || true
          if [ -s "release-diffs/other.diff" ]; then
            LINES=$(wc -l < "release-diffs/other.diff")
            echo "  - release-diffs/other.diff: $LINES lines" >> release-context.txt
          fi

          echo "" >> release-context.txt
          echo "## Diff Files Available" >> release-context.txt
          echo "Diffs are split by directory in release-diffs/ folder." >> release-context.txt
          echo "Read each diff file to understand changes in that component." >> release-context.txt
          ls -la release-diffs/ >> release-context.txt 2>/dev/null || echo "No diff files generated" >> release-context.txt

          echo "Context generated: $(wc -l < release-context.txt) lines"
          echo "Diff files created in release-diffs/"
          ls -la release-diffs/ 2>/dev/null || echo "No diff files"

      - name: Generate release notes with Claude
        if: steps.tag.outputs.SKIP != 'true'
        id: generate-notes
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          max_turns: 30
          model: claude-opus-4-5-20251101
          prompt: |
            Generate comprehensive release notes for GAIA version ${{ steps.tag.outputs.TAG_NAME }}.

            ## FIRST ACTIONS
            1. Read release-context.txt - Contains commit log, contributors, PRs, and list of diff files
            2. Read src/gaia/version.py - Get the current version info
            3. Read CLAUDE.md for project context

            ## ITERATIVE DIFF ANALYSIS
            Diffs are split by component in the `release-diffs/` folder:
            - release-diffs/src.diff - Source code changes (most important!)
            - release-diffs/tests.diff - Test changes
            - release-diffs/docs.diff - Documentation changes
            - release-diffs/.github.diff - CI/workflow changes
            - release-diffs/installer.diff - Installer changes
            - release-diffs/examples.diff - Example changes
            - release-diffs/other.diff - Other changes

            **Strategy for large diffs:**
            1. Start with release-diffs/src.diff - this contains the main feature changes
            2. For very large diffs (>1000 lines), read in chunks using offset/limit
            3. Summarize key changes from each component before writing final notes
            4. Focus on user-facing changes, not internal refactoring

            ## OUTPUT: TWO FILES REQUIRED

            You MUST write TWO files:

            ### 1. `RELEASE_NOTES.md` - For GitHub Release
            Plain markdown for the GitHub release page.

            ### 2. `docs/releases/${{ steps.tag.outputs.TAG_NAME }}.mdx` - For Documentation Site
            MDX format with Mintlify frontmatter for the documentation website.

            ## Release Notes Format (use for BOTH files)

            For the MDX file, add this frontmatter at the top:
            ```
            ---
            title: "${{ steps.tag.outputs.TAG_NAME }}"
            description: "[One-line summary of this release]"
            ---
            ```

            Then use this content structure for both files:

            # GAIA ${{ steps.tag.outputs.TAG_NAME }} Release Notes

            ## Overview

            [2-3 sentence summary of the most important changes. Highlight major new features, significant improvements, or breaking changes.]

            ## What's New

            ### üöÄ [Major Feature Name]
            [Description with code example if applicable]

            [Continue for each major new feature...]

            ## Improvements

            ### [Category - e.g., Agent UX, Performance, etc.]
            - **[Improvement name]**: [Brief description]

            ## Bug Fixes

            - **#[issue]**: [Description of fix]

            ## Infrastructure

            - [Change description]

            ## Breaking Changes

            [List any breaking changes, or "None. All changes are additive."]

            ## Full Changelog

            **[N] commits** from [N] contributors

            Key PRs:
            - #[number] - [PR title]

            Full Changelog: [${{ env.PREVIOUS_TAG }}...${{ steps.tag.outputs.TAG_NAME }}](https://github.com/amd/gaia/compare/${{ env.PREVIOUS_TAG }}...${{ steps.tag.outputs.TAG_NAME }})

            ## Guidelines

            1. **Be specific** - Reference actual file changes, not generic descriptions
            2. **Include code examples** - For new features, show how to use them
            3. **Categorize properly**: üöÄ new features, üéØ improvements, üêõ bug fixes, üîß infrastructure, üìö docs, üîí security
            4. **Link PRs and issues** - Use #number format
            5. **Credit contributors** - Mention contributors for significant changes
            6. **Highlight AMD-specific features** - NPU optimizations, Ryzen AI features

            ## What NOT to Include

            - Minor typo fixes (unless significant)
            - Internal refactoring without user impact
            - Dependency updates (unless security-related)
            - Copyright/license header changes

            IMPORTANT: You MUST write BOTH files:
            1. `RELEASE_NOTES.md` (for GitHub release)
            2. `docs/releases/${{ steps.tag.outputs.TAG_NAME }}.mdx` (for documentation site)

            ## MANDATORY: Review Your Changes
            After writing the release notes files, you MUST:
            1. Read back both files you wrote to verify they are correct
            2. Check that the MDX frontmatter is valid (title, description)
            3. Verify code examples are properly formatted
            4. Ensure all PR/issue references use correct #number format
            5. Confirm the changelog link uses the correct tag names

            Do NOT skip this review step - always verify your output before completing.

      - name: Verify and validate release notes
        if: steps.tag.outputs.SKIP != 'true'
        env:
          TAG_NAME: ${{ steps.tag.outputs.TAG_NAME }}
        run: |
          echo "Checking for generated release notes..."

          if [ ! -f "RELEASE_NOTES.md" ]; then
            echo "‚ùå RELEASE_NOTES.md was not generated"
            exit 1
          fi

          if [ ! -f "docs/releases/$TAG_NAME.mdx" ]; then
            echo "‚ùå docs/releases/$TAG_NAME.mdx was not generated"
            exit 1
          fi

          echo "‚úÖ Both release notes files exist"

          # Validate release notes structure
          python util/validate_release_notes.py "docs/releases/$TAG_NAME.mdx" --tag "$TAG_NAME"

      - name: Update docs.json with new release
        if: steps.tag.outputs.SKIP != 'true'
        env:
          TAG_NAME: ${{ steps.tag.outputs.TAG_NAME }}
        run: |
          # Add the new release to docs.json navigation
          # Insert at the beginning of the releases array (newest first)
          python << 'EOF'
          import json
          import os

          tag = os.environ['TAG_NAME']
          docs_json_path = 'docs/docs.json'

          with open(docs_json_path, 'r') as f:
              docs = json.load(f)

          # Find or create the Releases tab
          tabs = docs['navigation']['tabs']
          releases_tab = None

          for tab in tabs:
              if tab.get('tab') == 'Releases':
                  releases_tab = tab
                  break

          if releases_tab is None:
              # Create new Releases tab
              releases_tab = {
                  "tab": "Releases",
                  "groups": [
                      {
                          "group": "Release Notes",
                          "pages": []
                      }
                  ]
              }
              tabs.append(releases_tab)

          # Find the Release Notes group
          releases_group = None
          for group in releases_tab['groups']:
              if group.get('group') == 'Release Notes':
                  releases_group = group
                  break

          if releases_group is None:
              releases_group = {"group": "Release Notes", "pages": []}
              releases_tab['groups'].append(releases_group)

          # Add new release at the beginning (newest first)
          new_page = f"releases/{tag}"
          if new_page not in releases_group['pages']:
              releases_group['pages'].insert(0, new_page)

          with open(docs_json_path, 'w') as f:
              json.dump(docs, f, indent=2)
              f.write('\n')  # Ensure trailing newline for linting

          print(f"‚úÖ Added {new_page} to docs.json")
          EOF

      - name: Bump version.py to next patch version
        if: steps.tag.outputs.SKIP != 'true'
        env:
          TAG_NAME: ${{ steps.tag.outputs.TAG_NAME }}
        run: |
          # Extract version from tag (strip 'v' prefix if present)
          RELEASED_VERSION="${TAG_NAME#v}"
          echo "Released version: $RELEASED_VERSION"

          # Validate version format (must be X.Y.Z)
          if [[ ! "$RELEASED_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ö†Ô∏è Version '$RELEASED_VERSION' doesn't match X.Y.Z pattern"
            echo "Skipping auto-bump - please update version.py manually"
            echo "NEXT_VERSION=$RELEASED_VERSION" >> $GITHUB_ENV
            exit 0
          fi

          # Parse version components (MAJOR.MINOR.PATCH)
          IFS='.' read -r MAJOR MINOR PATCH <<< "$RELEASED_VERSION"

          # Bump patch version
          NEXT_PATCH=$((PATCH + 1))
          NEXT_VERSION="$MAJOR.$MINOR.$NEXT_PATCH"
          echo "Next development version: $NEXT_VERSION"

          # Update __version__ in version.py
          sed -i "s/__version__ = \".*\"/__version__ = \"$NEXT_VERSION\"/" src/gaia/version.py

          # Verify the change
          grep "__version__" src/gaia/version.py
          echo "NEXT_VERSION=$NEXT_VERSION" >> $GITHUB_ENV
          echo "‚úÖ version.py bumped to $NEXT_VERSION"

      - name: Commit release notes and version bump
        if: steps.tag.outputs.SKIP != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ steps.tag.outputs.TAG_NAME }}
          NEXT_VERSION: ${{ env.NEXT_VERSION }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add docs/releases/$TAG_NAME.mdx docs/docs.json src/gaia/version.py

          # Only commit if there are changes
          if git diff --cached --quiet; then
            echo "‚ö†Ô∏è No changes to commit"
          else
            git commit -m "release: $TAG_NAME notes + bump to $NEXT_VERSION for development"
            git push origin HEAD:main
            echo "‚úÖ Release notes committed, version bumped to $NEXT_VERSION"
          fi

      - name: Update GitHub Release
        if: steps.tag.outputs.SKIP != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ steps.tag.outputs.TAG_NAME }}
        run: |
          echo "Updating GitHub release with generated notes..."
          gh release edit "$TAG_NAME" --notes-file RELEASE_NOTES.md
          echo "‚úÖ GitHub release updated successfully"

      - name: Notify on failure
        if: failure() && steps.tag.outputs.SKIP != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ steps.tag.outputs.TAG_NAME || github.event.workflow_run.head_branch }}
        run: |
          # Fallback if TAG_NAME is empty
          if [ -z "$TAG_NAME" ]; then
            TAG_NAME="unknown"
          fi

          gh issue create \
            --title "‚ö†Ô∏è Release notes generation failed for $TAG_NAME" \
            --body "The automated release notes generation for **$TAG_NAME** failed.

          **Action required:** Please manually write release notes for this release.

          - Release: https://github.com/$GITHUB_REPOSITORY/releases/tag/$TAG_NAME
          - Workflow run: https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID

          cc @kovtcharov-amd" \
            --assignee kovtcharov-amd \
            --label "bug,release"
